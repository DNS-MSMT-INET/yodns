package internal

import (
	"crypto/rand"
	"encoding/binary"
	"sync"
	"time"
)

const (
	// Initial size of the idsInflight map
	initialMapSize        = 32
	defaultCoolDownPeriod = 5 * time.Second
)

// MessageIdGenerator generates 16-bit message ids. It is stateful, to ensure that no duplicates are inflight.
// A cooldown period ensures that ids are not reused for a certain time, in order to minimize the probability of faulty correlations.
type MessageIdGenerator struct {
	mu sync.Mutex

	// idsInflight contains IDs that are currently inflight
	idsInflight map[uint16]any

	// coolDownMap contains IDs that are not inflight anymore but should not be reused yet.
	// This coolDown reduces the probability of late or duplicate response to be associated with the wrong request
	coolDownMap map[uint16]time.Time

	// coolDownPeriod is the time after which an ID is removed from the coolDownMap and becomes available again
	coolDownPeriod time.Duration
}

// NewIdGen creates a new MessageIdGenerator
func NewIdGen() *MessageIdGenerator {
	return &MessageIdGenerator{
		idsInflight:    make(map[uint16]any, initialMapSize),
		coolDownMap:    make(map[uint16]time.Time, initialMapSize),
		coolDownPeriod: defaultCoolDownPeriod,
	}
}

// NewId generates a random id.
// Can be overwritten for unit testing purposes
var NewId = func() uint16 {
	var output uint16
	err := binary.Read(rand.Reader, binary.BigEndian, &output)
	if err != nil {
		panic("generating random id failed: " + err.Error())
	}

	return output
}

// GetFreeMessageID generates a messageId that guaranteed to have no collisions
// with other IDs generated by this method UNLESS they have been released
// GetFreeMessageID never returns 0.
func (gen *MessageIdGenerator) GetFreeMessageID() uint16 {
	gen.mu.Lock()
	defer gen.mu.Unlock()

	for i := 0; i < 100; i++ {
		msgID := NewId()

		// Do not allow 0, it makes life easier.
		// If we allow 0, and do err := new(dns.Msg).Unpack(),
		// we can never know if the message was partially unpacked and the ID is actually 0,
		// or whether the message was not unpacked at all. Err does not help us here.
		if msgID == 0 {
			continue
		}

		if coolDown, exists := gen.coolDownMap[msgID]; exists {
			if coolDown.After(time.Now()) {
				continue
			}
			delete(gen.coolDownMap, msgID)
		}

		if _, exists := gen.idsInflight[msgID]; !exists {
			gen.idsInflight[msgID] = nil
			return msgID
		}
	}

	// A connection is typically used for less than 100 messages simultaneously.
	// If 100 random draws don't generate a free id, we probably have a bug.
	panic("Could not generate a new ID")
}

// ReleaseMessageID releases an id acquired by GetMessageId so that it might be reused
// Returns true if an entry was released, false if the msgID was not present in the map.
func (gen *MessageIdGenerator) ReleaseMessageID(msgID uint16) bool {
	gen.mu.Lock()
	_, exists := gen.idsInflight[msgID]
	delete(gen.idsInflight, msgID)
	gen.coolDownMap[msgID] = time.Now().Add(gen.coolDownPeriod)
	gen.mu.Unlock()

	return exists
}

// InflightIDs returns a list of all message IDs that are currently in use.
func (gen *MessageIdGenerator) InflightIDs() []uint16 {
	gen.mu.Lock()
	defer gen.mu.Unlock()

	return keys(gen.idsInflight)
}

func keys[K comparable, V any](m map[K]V) []K {
	keys := make([]K, len(m))
	i := 0
	for k := range m {
		keys[i] = k
		i++
	}
	return keys
}
